// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'characters_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$CharacterEvents {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getCharacters,
    required TResult Function(int id) detailCharacters,
    required TResult Function(String name, String status, String gender)
        searchCharacters,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? getCharacters,
    TResult Function(int id)? detailCharacters,
    TResult Function(String name, String status, String gender)?
        searchCharacters,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getCharacters,
    TResult Function(int id)? detailCharacters,
    TResult Function(String name, String status, String gender)?
        searchCharacters,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetCharacters value) getCharacters,
    required TResult Function(_DetailCharacters value) detailCharacters,
    required TResult Function(_SearchCharacters value) searchCharacters,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_GetCharacters value)? getCharacters,
    TResult Function(_DetailCharacters value)? detailCharacters,
    TResult Function(_SearchCharacters value)? searchCharacters,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetCharacters value)? getCharacters,
    TResult Function(_DetailCharacters value)? detailCharacters,
    TResult Function(_SearchCharacters value)? searchCharacters,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CharacterEventsCopyWith<$Res> {
  factory $CharacterEventsCopyWith(
          CharacterEvents value, $Res Function(CharacterEvents) then) =
      _$CharacterEventsCopyWithImpl<$Res>;
}

/// @nodoc
class _$CharacterEventsCopyWithImpl<$Res>
    implements $CharacterEventsCopyWith<$Res> {
  _$CharacterEventsCopyWithImpl(this._value, this._then);

  final CharacterEvents _value;
  // ignore: unused_field
  final $Res Function(CharacterEvents) _then;
}

/// @nodoc
abstract class _$$_GetCharactersCopyWith<$Res> {
  factory _$$_GetCharactersCopyWith(
          _$_GetCharacters value, $Res Function(_$_GetCharacters) then) =
      __$$_GetCharactersCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_GetCharactersCopyWithImpl<$Res>
    extends _$CharacterEventsCopyWithImpl<$Res>
    implements _$$_GetCharactersCopyWith<$Res> {
  __$$_GetCharactersCopyWithImpl(
      _$_GetCharacters _value, $Res Function(_$_GetCharacters) _then)
      : super(_value, (v) => _then(v as _$_GetCharacters));

  @override
  _$_GetCharacters get _value => super._value as _$_GetCharacters;
}

/// @nodoc

class _$_GetCharacters with DiagnosticableTreeMixin implements _GetCharacters {
  const _$_GetCharacters();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CharacterEvents.getCharacters()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
        .add(DiagnosticsProperty('type', 'CharacterEvents.getCharacters'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_GetCharacters);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getCharacters,
    required TResult Function(int id) detailCharacters,
    required TResult Function(String name, String status, String gender)
        searchCharacters,
  }) {
    return getCharacters();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? getCharacters,
    TResult Function(int id)? detailCharacters,
    TResult Function(String name, String status, String gender)?
        searchCharacters,
  }) {
    return getCharacters?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getCharacters,
    TResult Function(int id)? detailCharacters,
    TResult Function(String name, String status, String gender)?
        searchCharacters,
    required TResult orElse(),
  }) {
    if (getCharacters != null) {
      return getCharacters();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetCharacters value) getCharacters,
    required TResult Function(_DetailCharacters value) detailCharacters,
    required TResult Function(_SearchCharacters value) searchCharacters,
  }) {
    return getCharacters(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_GetCharacters value)? getCharacters,
    TResult Function(_DetailCharacters value)? detailCharacters,
    TResult Function(_SearchCharacters value)? searchCharacters,
  }) {
    return getCharacters?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetCharacters value)? getCharacters,
    TResult Function(_DetailCharacters value)? detailCharacters,
    TResult Function(_SearchCharacters value)? searchCharacters,
    required TResult orElse(),
  }) {
    if (getCharacters != null) {
      return getCharacters(this);
    }
    return orElse();
  }
}

abstract class _GetCharacters implements CharacterEvents {
  const factory _GetCharacters() = _$_GetCharacters;
}

/// @nodoc
abstract class _$$_DetailCharactersCopyWith<$Res> {
  factory _$$_DetailCharactersCopyWith(
          _$_DetailCharacters value, $Res Function(_$_DetailCharacters) then) =
      __$$_DetailCharactersCopyWithImpl<$Res>;
  $Res call({int id});
}

/// @nodoc
class __$$_DetailCharactersCopyWithImpl<$Res>
    extends _$CharacterEventsCopyWithImpl<$Res>
    implements _$$_DetailCharactersCopyWith<$Res> {
  __$$_DetailCharactersCopyWithImpl(
      _$_DetailCharacters _value, $Res Function(_$_DetailCharacters) _then)
      : super(_value, (v) => _then(v as _$_DetailCharacters));

  @override
  _$_DetailCharacters get _value => super._value as _$_DetailCharacters;

  @override
  $Res call({
    Object? id = freezed,
  }) {
    return _then(_$_DetailCharacters(
      id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$_DetailCharacters
    with DiagnosticableTreeMixin
    implements _DetailCharacters {
  const _$_DetailCharacters(this.id);

  @override
  final int id;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CharacterEvents.detailCharacters(id: $id)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'CharacterEvents.detailCharacters'))
      ..add(DiagnosticsProperty('id', id));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_DetailCharacters &&
            const DeepCollectionEquality().equals(other.id, id));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(id));

  @JsonKey(ignore: true)
  @override
  _$$_DetailCharactersCopyWith<_$_DetailCharacters> get copyWith =>
      __$$_DetailCharactersCopyWithImpl<_$_DetailCharacters>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getCharacters,
    required TResult Function(int id) detailCharacters,
    required TResult Function(String name, String status, String gender)
        searchCharacters,
  }) {
    return detailCharacters(id);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? getCharacters,
    TResult Function(int id)? detailCharacters,
    TResult Function(String name, String status, String gender)?
        searchCharacters,
  }) {
    return detailCharacters?.call(id);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getCharacters,
    TResult Function(int id)? detailCharacters,
    TResult Function(String name, String status, String gender)?
        searchCharacters,
    required TResult orElse(),
  }) {
    if (detailCharacters != null) {
      return detailCharacters(id);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetCharacters value) getCharacters,
    required TResult Function(_DetailCharacters value) detailCharacters,
    required TResult Function(_SearchCharacters value) searchCharacters,
  }) {
    return detailCharacters(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_GetCharacters value)? getCharacters,
    TResult Function(_DetailCharacters value)? detailCharacters,
    TResult Function(_SearchCharacters value)? searchCharacters,
  }) {
    return detailCharacters?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetCharacters value)? getCharacters,
    TResult Function(_DetailCharacters value)? detailCharacters,
    TResult Function(_SearchCharacters value)? searchCharacters,
    required TResult orElse(),
  }) {
    if (detailCharacters != null) {
      return detailCharacters(this);
    }
    return orElse();
  }
}

abstract class _DetailCharacters implements CharacterEvents {
  const factory _DetailCharacters(final int id) = _$_DetailCharacters;

  int get id;
  @JsonKey(ignore: true)
  _$$_DetailCharactersCopyWith<_$_DetailCharacters> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_SearchCharactersCopyWith<$Res> {
  factory _$$_SearchCharactersCopyWith(
          _$_SearchCharacters value, $Res Function(_$_SearchCharacters) then) =
      __$$_SearchCharactersCopyWithImpl<$Res>;
  $Res call({String name, String status, String gender});
}

/// @nodoc
class __$$_SearchCharactersCopyWithImpl<$Res>
    extends _$CharacterEventsCopyWithImpl<$Res>
    implements _$$_SearchCharactersCopyWith<$Res> {
  __$$_SearchCharactersCopyWithImpl(
      _$_SearchCharacters _value, $Res Function(_$_SearchCharacters) _then)
      : super(_value, (v) => _then(v as _$_SearchCharacters));

  @override
  _$_SearchCharacters get _value => super._value as _$_SearchCharacters;

  @override
  $Res call({
    Object? name = freezed,
    Object? status = freezed,
    Object? gender = freezed,
  }) {
    return _then(_$_SearchCharacters(
      name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      status == freezed
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as String,
      gender == freezed
          ? _value.gender
          : gender // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_SearchCharacters
    with DiagnosticableTreeMixin
    implements _SearchCharacters {
  const _$_SearchCharacters(this.name, this.status, this.gender);

  @override
  final String name;
  @override
  final String status;
  @override
  final String gender;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CharacterEvents.searchCharacters(name: $name, status: $status, gender: $gender)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'CharacterEvents.searchCharacters'))
      ..add(DiagnosticsProperty('name', name))
      ..add(DiagnosticsProperty('status', status))
      ..add(DiagnosticsProperty('gender', gender));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SearchCharacters &&
            const DeepCollectionEquality().equals(other.name, name) &&
            const DeepCollectionEquality().equals(other.status, status) &&
            const DeepCollectionEquality().equals(other.gender, gender));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(name),
      const DeepCollectionEquality().hash(status),
      const DeepCollectionEquality().hash(gender));

  @JsonKey(ignore: true)
  @override
  _$$_SearchCharactersCopyWith<_$_SearchCharacters> get copyWith =>
      __$$_SearchCharactersCopyWithImpl<_$_SearchCharacters>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getCharacters,
    required TResult Function(int id) detailCharacters,
    required TResult Function(String name, String status, String gender)
        searchCharacters,
  }) {
    return searchCharacters(name, status, gender);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? getCharacters,
    TResult Function(int id)? detailCharacters,
    TResult Function(String name, String status, String gender)?
        searchCharacters,
  }) {
    return searchCharacters?.call(name, status, gender);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getCharacters,
    TResult Function(int id)? detailCharacters,
    TResult Function(String name, String status, String gender)?
        searchCharacters,
    required TResult orElse(),
  }) {
    if (searchCharacters != null) {
      return searchCharacters(name, status, gender);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetCharacters value) getCharacters,
    required TResult Function(_DetailCharacters value) detailCharacters,
    required TResult Function(_SearchCharacters value) searchCharacters,
  }) {
    return searchCharacters(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_GetCharacters value)? getCharacters,
    TResult Function(_DetailCharacters value)? detailCharacters,
    TResult Function(_SearchCharacters value)? searchCharacters,
  }) {
    return searchCharacters?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetCharacters value)? getCharacters,
    TResult Function(_DetailCharacters value)? detailCharacters,
    TResult Function(_SearchCharacters value)? searchCharacters,
    required TResult orElse(),
  }) {
    if (searchCharacters != null) {
      return searchCharacters(this);
    }
    return orElse();
  }
}

abstract class _SearchCharacters implements CharacterEvents {
  const factory _SearchCharacters(
          final String name, final String status, final String gender) =
      _$_SearchCharacters;

  String get name;
  String get status;
  String get gender;
  @JsonKey(ignore: true)
  _$$_SearchCharactersCopyWith<_$_SearchCharacters> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$CharacterStates {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<CharactersModel> characters) initial,
    required TResult Function(List<CharactersModel> characters) loading,
    required TResult Function(List<CharactersModel> characters) succes,
    required TResult Function(String error) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(List<CharactersModel> characters)? initial,
    TResult Function(List<CharactersModel> characters)? loading,
    TResult Function(List<CharactersModel> characters)? succes,
    TResult Function(String error)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<CharactersModel> characters)? initial,
    TResult Function(List<CharactersModel> characters)? loading,
    TResult Function(List<CharactersModel> characters)? succes,
    TResult Function(String error)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Succes value) succes,
    required TResult Function(_Error value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Succes value)? succes,
    TResult Function(_Error value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Succes value)? succes,
    TResult Function(_Error value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CharacterStatesCopyWith<$Res> {
  factory $CharacterStatesCopyWith(
          CharacterStates value, $Res Function(CharacterStates) then) =
      _$CharacterStatesCopyWithImpl<$Res>;
}

/// @nodoc
class _$CharacterStatesCopyWithImpl<$Res>
    implements $CharacterStatesCopyWith<$Res> {
  _$CharacterStatesCopyWithImpl(this._value, this._then);

  final CharacterStates _value;
  // ignore: unused_field
  final $Res Function(CharacterStates) _then;
}

/// @nodoc
abstract class _$$_InitialCopyWith<$Res> {
  factory _$$_InitialCopyWith(
          _$_Initial value, $Res Function(_$_Initial) then) =
      __$$_InitialCopyWithImpl<$Res>;
  $Res call({List<CharactersModel> characters});
}

/// @nodoc
class __$$_InitialCopyWithImpl<$Res> extends _$CharacterStatesCopyWithImpl<$Res>
    implements _$$_InitialCopyWith<$Res> {
  __$$_InitialCopyWithImpl(_$_Initial _value, $Res Function(_$_Initial) _then)
      : super(_value, (v) => _then(v as _$_Initial));

  @override
  _$_Initial get _value => super._value as _$_Initial;

  @override
  $Res call({
    Object? characters = freezed,
  }) {
    return _then(_$_Initial(
      characters: characters == freezed
          ? _value._characters
          : characters // ignore: cast_nullable_to_non_nullable
              as List<CharactersModel>,
    ));
  }
}

/// @nodoc

class _$_Initial with DiagnosticableTreeMixin implements _Initial {
  const _$_Initial({required final List<CharactersModel> characters})
      : _characters = characters;

  final List<CharactersModel> _characters;
  @override
  List<CharactersModel> get characters {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_characters);
  }

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CharacterStates.initial(characters: $characters)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'CharacterStates.initial'))
      ..add(DiagnosticsProperty('characters', characters));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Initial &&
            const DeepCollectionEquality()
                .equals(other._characters, _characters));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_characters));

  @JsonKey(ignore: true)
  @override
  _$$_InitialCopyWith<_$_Initial> get copyWith =>
      __$$_InitialCopyWithImpl<_$_Initial>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<CharactersModel> characters) initial,
    required TResult Function(List<CharactersModel> characters) loading,
    required TResult Function(List<CharactersModel> characters) succes,
    required TResult Function(String error) error,
  }) {
    return initial(characters);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(List<CharactersModel> characters)? initial,
    TResult Function(List<CharactersModel> characters)? loading,
    TResult Function(List<CharactersModel> characters)? succes,
    TResult Function(String error)? error,
  }) {
    return initial?.call(characters);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<CharactersModel> characters)? initial,
    TResult Function(List<CharactersModel> characters)? loading,
    TResult Function(List<CharactersModel> characters)? succes,
    TResult Function(String error)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(characters);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Succes value) succes,
    required TResult Function(_Error value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Succes value)? succes,
    TResult Function(_Error value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Succes value)? succes,
    TResult Function(_Error value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements CharacterStates {
  const factory _Initial({required final List<CharactersModel> characters}) =
      _$_Initial;

  List<CharactersModel> get characters;
  @JsonKey(ignore: true)
  _$$_InitialCopyWith<_$_Initial> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_LoadingCopyWith<$Res> {
  factory _$$_LoadingCopyWith(
          _$_Loading value, $Res Function(_$_Loading) then) =
      __$$_LoadingCopyWithImpl<$Res>;
  $Res call({List<CharactersModel> characters});
}

/// @nodoc
class __$$_LoadingCopyWithImpl<$Res> extends _$CharacterStatesCopyWithImpl<$Res>
    implements _$$_LoadingCopyWith<$Res> {
  __$$_LoadingCopyWithImpl(_$_Loading _value, $Res Function(_$_Loading) _then)
      : super(_value, (v) => _then(v as _$_Loading));

  @override
  _$_Loading get _value => super._value as _$_Loading;

  @override
  $Res call({
    Object? characters = freezed,
  }) {
    return _then(_$_Loading(
      characters: characters == freezed
          ? _value._characters
          : characters // ignore: cast_nullable_to_non_nullable
              as List<CharactersModel>,
    ));
  }
}

/// @nodoc

class _$_Loading with DiagnosticableTreeMixin implements _Loading {
  const _$_Loading({required final List<CharactersModel> characters})
      : _characters = characters;

  final List<CharactersModel> _characters;
  @override
  List<CharactersModel> get characters {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_characters);
  }

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CharacterStates.loading(characters: $characters)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'CharacterStates.loading'))
      ..add(DiagnosticsProperty('characters', characters));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Loading &&
            const DeepCollectionEquality()
                .equals(other._characters, _characters));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_characters));

  @JsonKey(ignore: true)
  @override
  _$$_LoadingCopyWith<_$_Loading> get copyWith =>
      __$$_LoadingCopyWithImpl<_$_Loading>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<CharactersModel> characters) initial,
    required TResult Function(List<CharactersModel> characters) loading,
    required TResult Function(List<CharactersModel> characters) succes,
    required TResult Function(String error) error,
  }) {
    return loading(characters);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(List<CharactersModel> characters)? initial,
    TResult Function(List<CharactersModel> characters)? loading,
    TResult Function(List<CharactersModel> characters)? succes,
    TResult Function(String error)? error,
  }) {
    return loading?.call(characters);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<CharactersModel> characters)? initial,
    TResult Function(List<CharactersModel> characters)? loading,
    TResult Function(List<CharactersModel> characters)? succes,
    TResult Function(String error)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(characters);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Succes value) succes,
    required TResult Function(_Error value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Succes value)? succes,
    TResult Function(_Error value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Succes value)? succes,
    TResult Function(_Error value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _Loading implements CharacterStates {
  const factory _Loading({required final List<CharactersModel> characters}) =
      _$_Loading;

  List<CharactersModel> get characters;
  @JsonKey(ignore: true)
  _$$_LoadingCopyWith<_$_Loading> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_SuccesCopyWith<$Res> {
  factory _$$_SuccesCopyWith(_$_Succes value, $Res Function(_$_Succes) then) =
      __$$_SuccesCopyWithImpl<$Res>;
  $Res call({List<CharactersModel> characters});
}

/// @nodoc
class __$$_SuccesCopyWithImpl<$Res> extends _$CharacterStatesCopyWithImpl<$Res>
    implements _$$_SuccesCopyWith<$Res> {
  __$$_SuccesCopyWithImpl(_$_Succes _value, $Res Function(_$_Succes) _then)
      : super(_value, (v) => _then(v as _$_Succes));

  @override
  _$_Succes get _value => super._value as _$_Succes;

  @override
  $Res call({
    Object? characters = freezed,
  }) {
    return _then(_$_Succes(
      characters == freezed
          ? _value._characters
          : characters // ignore: cast_nullable_to_non_nullable
              as List<CharactersModel>,
    ));
  }
}

/// @nodoc

class _$_Succes with DiagnosticableTreeMixin implements _Succes {
  const _$_Succes(final List<CharactersModel> characters)
      : _characters = characters;

  final List<CharactersModel> _characters;
  @override
  List<CharactersModel> get characters {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_characters);
  }

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CharacterStates.succes(characters: $characters)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'CharacterStates.succes'))
      ..add(DiagnosticsProperty('characters', characters));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Succes &&
            const DeepCollectionEquality()
                .equals(other._characters, _characters));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_characters));

  @JsonKey(ignore: true)
  @override
  _$$_SuccesCopyWith<_$_Succes> get copyWith =>
      __$$_SuccesCopyWithImpl<_$_Succes>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<CharactersModel> characters) initial,
    required TResult Function(List<CharactersModel> characters) loading,
    required TResult Function(List<CharactersModel> characters) succes,
    required TResult Function(String error) error,
  }) {
    return succes(characters);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(List<CharactersModel> characters)? initial,
    TResult Function(List<CharactersModel> characters)? loading,
    TResult Function(List<CharactersModel> characters)? succes,
    TResult Function(String error)? error,
  }) {
    return succes?.call(characters);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<CharactersModel> characters)? initial,
    TResult Function(List<CharactersModel> characters)? loading,
    TResult Function(List<CharactersModel> characters)? succes,
    TResult Function(String error)? error,
    required TResult orElse(),
  }) {
    if (succes != null) {
      return succes(characters);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Succes value) succes,
    required TResult Function(_Error value) error,
  }) {
    return succes(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Succes value)? succes,
    TResult Function(_Error value)? error,
  }) {
    return succes?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Succes value)? succes,
    TResult Function(_Error value)? error,
    required TResult orElse(),
  }) {
    if (succes != null) {
      return succes(this);
    }
    return orElse();
  }
}

abstract class _Succes implements CharacterStates {
  const factory _Succes(final List<CharactersModel> characters) = _$_Succes;

  List<CharactersModel> get characters;
  @JsonKey(ignore: true)
  _$$_SuccesCopyWith<_$_Succes> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_ErrorCopyWith<$Res> {
  factory _$$_ErrorCopyWith(_$_Error value, $Res Function(_$_Error) then) =
      __$$_ErrorCopyWithImpl<$Res>;
  $Res call({String error});
}

/// @nodoc
class __$$_ErrorCopyWithImpl<$Res> extends _$CharacterStatesCopyWithImpl<$Res>
    implements _$$_ErrorCopyWith<$Res> {
  __$$_ErrorCopyWithImpl(_$_Error _value, $Res Function(_$_Error) _then)
      : super(_value, (v) => _then(v as _$_Error));

  @override
  _$_Error get _value => super._value as _$_Error;

  @override
  $Res call({
    Object? error = freezed,
  }) {
    return _then(_$_Error(
      error == freezed
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_Error with DiagnosticableTreeMixin implements _Error {
  const _$_Error(this.error);

  @override
  final String error;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CharacterStates.error(error: $error)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'CharacterStates.error'))
      ..add(DiagnosticsProperty('error', error));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Error &&
            const DeepCollectionEquality().equals(other.error, error));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(error));

  @JsonKey(ignore: true)
  @override
  _$$_ErrorCopyWith<_$_Error> get copyWith =>
      __$$_ErrorCopyWithImpl<_$_Error>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<CharactersModel> characters) initial,
    required TResult Function(List<CharactersModel> characters) loading,
    required TResult Function(List<CharactersModel> characters) succes,
    required TResult Function(String error) error,
  }) {
    return error(this.error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(List<CharactersModel> characters)? initial,
    TResult Function(List<CharactersModel> characters)? loading,
    TResult Function(List<CharactersModel> characters)? succes,
    TResult Function(String error)? error,
  }) {
    return error?.call(this.error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<CharactersModel> characters)? initial,
    TResult Function(List<CharactersModel> characters)? loading,
    TResult Function(List<CharactersModel> characters)? succes,
    TResult Function(String error)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this.error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Succes value) succes,
    required TResult Function(_Error value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Succes value)? succes,
    TResult Function(_Error value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Succes value)? succes,
    TResult Function(_Error value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _Error implements CharacterStates {
  const factory _Error(final String error) = _$_Error;

  String get error;
  @JsonKey(ignore: true)
  _$$_ErrorCopyWith<_$_Error> get copyWith =>
      throw _privateConstructorUsedError;
}
